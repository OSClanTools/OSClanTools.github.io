<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TileTrials Board Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          boxShadow: {
            soft: "0 8px 30px rgba(0,0,0,0.08)",
          }
        }
      }
    }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Fonts */
    @font-face {
      font-family: 'RuneScape-Quill';
      src: url('assets/font/RuneScape-Quill.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    html,
    body {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: url('assets/images/bg.png') center / cover fixed no-repeat;
      min-height: 100vh;
    }

    :root {
      --tile: 84px;
      --bronze: #cd7f32;
      --bronze-dark: #8a531e;
      --ink: #2c1a0e;
    }

    .drag-handle {
      cursor: grab;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .scrollbar-thin::-webkit-scrollbar {
      height: 8px;
      width: 8px;
    }

    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 9999px;
    }

    /* Tile look: parchment fill + bronze frame to mimic renderer */
    .tt-tile {
      position: relative;
      width: var(--tile);
      height: var(--tile);
      background: url('assets/images/parchment.png') center / cover no-repeat;
      border: 3px solid var(--bronze);
      border-radius: 6px;
      box-shadow:
        0 2px 2px rgba(0, 0, 0, 0.45),
        inset 0 0 0 1.5px var(--bronze-dark),
        inset 0 6px 10px rgba(255, 255, 255, 0.22);
      transition: transform .06s ease;
    }

    .tt-tile:hover {
      transform: translateY(-1px);
    }

    .tt-tile-num {
      position: absolute;
      top: 4px;
      right: 4px;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      font-size: 14px;
      color: var(--ink);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.85);
      letter-spacing: .3px;
      user-select: none;
    }

    .tt-tile-icon {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: calc(var(--tile) * .72);
      height: calc(var(--tile) * .72);
      object-fit: contain;
      background: rgba(0, 0, 0, 0.08);
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
    }

    .tt-tile-name {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      max-width: calc(var(--tile) * .86);
      text-align: center;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      color: var(--ink);
      text-shadow: 0 1px 0 rgba(0, 0, 0, .85);
      font-size: 13px;
      line-height: 1.05;
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tt-tile-badge {
      position: absolute;
      left: 6px;
      bottom: 6px;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.55);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
      display: grid;
      place-items: center;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      color: #ffd166;
      font-size: 11px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .85);
      user-select: none;
    }

    /* Each grid cell = exactly one tile */
    .tt-cell {
      width: var(--tile);
      height: var(--tile);
      position: relative;
      transition: transform .16s cubic-bezier(.2, .7, .2, 1), box-shadow .16s cubic-bezier(.2, .7, .2, 1);
    }

    .tt-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 16px;
    }

    @media (max-width: 1024px) {
      .tt-layout {
        grid-template-columns: 1fr;
      }
    }

    .tt-board-wrap {
      position: relative;
      overflow: auto;
      padding: 8px;
      background: rgba(255, 255, 255, 0.35);
      border: 1px solid rgba(0, 0, 0, 0.06);
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(2px);
      max-height: calc((var(--tile) * 15) + (12px * 14) + 24px);
    }


    /* Keep the visual wrapper the same size as the tile while we fix offset */
    .tt-card {
      width: var(--tile);
      padding: 0;
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .tt-id {
      font-size: 11px;
      color: rgba(0, 0, 0, 0.55);
      margin-left: auto;
    }

    /* Grid container for board preview */
    .tt-grid {
      display: grid;
      grid-auto-rows: var(--tile);
      grid-auto-flow: row dense;
      /* enables smooth cascading when dragging */
      align-content: start;
      justify-content: start;
      gap: 12px;
    }

    /* Start/Finish marker badges */
    .tt-marker {
      position: absolute;
      top: 6px;
      left: 6px;
      background: linear-gradient(180deg, #22c55e, #16a34a);
      color: #fff;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
      user-select: none;
    }

    .tt-marker.finish {
      background: linear-gradient(180deg, #f59e0b, #b45309);
    }

    /* Prevent selection/drag ghost blue marquee while dragging */
    .tt-board-wrap,
    .tt-grid,
    .tt-cell,
    .tt-tile,
    .tt-tile * {
      -webkit-user-select: none;
      user-select: none;
    }

    /* Prevent browser focus outlines on the tile itself */
    .tt-tile:focus,
    .tt-tile:focus-visible {
      outline: none;
    }

    /* Prevent image-native drag ghost */
    .tt-tile img {
      -webkit-user-drag: none;
    }

    .tt-ghost .tt-tile {
      visibility: hidden;
    }

    .tt-chosen .tt-tile {
      transform: scale(1.04);
      box-shadow: 0 10px 18px rgba(0, 0, 0, .25), inset 0 0 0 1.5px rgba(0, 0, 0, .25);
    }

    .tt-drag {
      opacity: .98;
      cursor: grabbing !important;
      transition: none;
    }

    .tt-drag .tt-tile {
      transform: scale(1.02);
      /* subtle */
      box-shadow: 0 8px 12px rgba(0, 0, 0, .20), inset 0 0 0 1px rgba(0, 0, 0, .2);
    }

    .tt-start .tt-tile {
      background: url('assets/images/parchment.png') center / cover no-repeat;
      border-color: #22c55e;
      box-shadow:
        0 2px 2px rgba(0, 0, 0, .45),
        inset 0 0 0 1.5px #15803d,
        inset 0 6px 10px rgba(255, 255, 255, .22);
    }

    .tt-start .tt-tile .tt-tile-num {
      display: none;
    }

    .tt-start .tt-tile-name {
      font-size: 14px;
      color: #14532d;
    }

    /* Drop highlight for tiles when dragging an effect token */
    .tt-drop-target .tt-tile {
      outline: 2px dashed rgba(34, 197, 94, .9);
      outline-offset: 2px;
    }

    /* Effect token look */
    .tt-token {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, .05);
      border: 1px solid rgba(0, 0, 0, .12);
      border-radius: 10px;
      font-size: 12px;
      cursor: grab;
    }

    .tt-token:active {
      cursor: grabbing;
    }

    .tt-token .dot {
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      background: #0ea5e9;
    }
  </style>
</head>

<body class="bg-slate-50">
  <div id="root"></div>

  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

  <script>
    const { useState, useMemo, useEffect, useRef } = React;

    // All supported effects and their suggested default trigger/params
    const EFFECTS = [
      { kind: 'none', label: 'None (no effect)', defaultTrigger: null, params: [] },
      { kind: 'move_forward', label: 'Move Forward', defaultTrigger: 'on_next_roll', params: [{ name: 'amount', type: 'number', min: 1, step: 1, placeholder: 'e.g. 2' }] },
      { kind: 'move_back', label: 'Move Back', defaultTrigger: 'on_next_roll', params: [{ name: 'amount', type: 'number', min: 1, step: 1, placeholder: 'e.g. 1' }] },
      { kind: 'teleport_to', label: 'Teleport To (index)', defaultTrigger: 'on_next_roll', params: [{ name: 'index', type: 'number', min: 1, step: 1, placeholder: 'tile index' }] },
      { kind: 'go_to_start', label: 'Go To START', defaultTrigger: 'on_land', params: [] },
      { kind: 'set_checkpoint', label: 'Set Checkpoint', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'go_to_checkpoint', label: 'Go To Checkpoint', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'reverse_next_roll', label: 'Reverse Next Roll', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'double_next_roll', label: 'Double Next Roll', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'shield_next_negative', label: 'Shield Next Negative', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'swap_with_random_team', label: 'Swap with Random Team', defaultTrigger: 'on_land', params: [] },
      { kind: 'swap_with_leader', label: 'Swap with Leader', defaultTrigger: 'on_land', params: [] },
    ];

    const DEFAULT_ICON = 'https://cdn.jsdelivr.net/gh/tabler/tabler-icons@latest/icons/outlet.svg';

    function nanoid(size = 8) {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let s = '';
      for (let i = 0; i < size; i++) s += chars[Math.floor(Math.random() * chars.length)];
      return s;
    }

    function useAutoCols(maxCols = 15) {
      const gridRef = React.useRef(null);
      const [cols, setCols] = React.useState(1);

      React.useEffect(() => {
        if (!gridRef.current) return;

        const el = gridRef.current;

        const compute = () => {
          // Read CSS --tile and gap to estimate how many columns fit
          const root = getComputedStyle(document.documentElement);
          const tile = parseFloat(root.getPropertyValue('--tile')) || 84;
          const gap = 12; // keep in sync with .tt-grid gap
          const width = el.clientWidth; // visible width of grid container
          // columns = floor((width + gap) / (tile + gap)), clamped 1..maxCols
          const perRow = Math.max(1, Math.min(maxCols, Math.floor((width + gap) / (tile + gap))));
          setCols(perRow);
        };

        // ResizeObserver to track container width
        const ro = new ResizeObserver(() => compute());
        ro.observe(el);

        // First compute now (in case observer fires late)
        compute();

        return () => ro.disconnect();
      }, [maxCols]);

      return [gridRef, cols];
    }

    function makeDefaultTile(n) {
      return {
        id: String(n),
        tileNumber: n,
        name: `Tile ${n}`,
        desc: '',
        iconFile: '',
        effect: { kind: 'none' },
        meta: { presetId: 'none', opts: {}, attached: false }
      };
    }

    function coerceNumber(v, fallback) {
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    }

    // Extract tiles from different shapes
    function extractTilesFromAny(raw) {
      try {
        if (Array.isArray(raw)) return raw;
        if (Array.isArray(raw?.tiles)) return raw.tiles;
        if (Array.isArray(raw?.board?.tiles)) return raw.board.tiles;
        if (raw && (raw.tileNumber || raw.name || raw.desc)) return [raw];
        if (raw && typeof raw === 'object') {
          const entries = Object.entries(raw);
          if (entries.every(([k, v]) => v && typeof v === 'object')) {
            return entries.map(([k, v]) => ({ id: v.id ?? k, tileNumber: v.tileNumber ?? Number(k), ...v }));
          }
        }
      } catch { }
      return [];
    }

    function normalizeImportedTiles(list) {
      const tiles = [];
      for (let i = 0; i < list.length; i++) {
        const t = list[i] || {};
        const num = coerceNumber(t.tileNumber ?? t.id ?? i + 1, i + 1);
        const id = String(t.id ?? num);
        const clean = {
          id,
          tileNumber: num,
          name: String(t.name ?? `Tile ${num}`),
          desc: String(t.desc ?? ''),
          iconFile: String(t.iconFile ?? t.iconUrl ?? t.iconURL ?? t.icon ?? t.icon_link ?? t.iconLink ?? ''),
          effect: (() => {
            const eff = t.effect || {};
            if (eff == null || eff.kind === 'none') return { kind: 'none' };
            const kind = String(eff.kind || 'move_forward');
            const meta = EFFECTS.find(e => e.kind === kind) || EFFECTS[0];
            const trigger = eff.trigger || meta.defaultTrigger || 'on_next_roll';
            const obj = { kind, trigger };
            if ('amount' in eff) obj.amount = coerceNumber(eff.amount, 1);
            if ('index' in eff) obj.index = coerceNumber(eff.index, 1);
            return obj;
          })(),
          meta: (() => {
            const eff = t.effect || {};
            if (eff == null || eff.kind === 'none') return { presetId: 'none', opts: {}, attached: false };
            const kind = String(eff.kind || 'move_forward');
            const opts = {};
            if ('amount' in eff) opts.amount = coerceNumber(eff.amount, 1);
            if ('index' in eff) opts.index = coerceNumber(eff.index, 1);
            return { presetId: kind, opts, attached: true };
          })()
        };
        tiles.push(clean);
      }

      tiles.sort((a, b) => a.tileNumber - b.tileNumber);
      tiles.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
      return tiles;
    }

    function download(filename, text) {
      const blob = new Blob([text], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

function useSortable(containerRef, items, setItems) {
  const { useEffect } = React;

  useEffect(() => {
    if (!containerRef.current) return;

    const el = containerRef.current;
    const sortable = new Sortable(el, {
      dataIdAttr: 'data-id',
      draggable: '.tt-cell:not(.tt-fixed)',  // ðŸ‘ˆ ignore first tile
      handle: '.tt-tile',
      animation: 90,
      easing: 'cubic-bezier(.2,.7,.2,1)',
      forceFallback: true,
      fallbackOnBody: true,
      fallbackTolerance: 2,
      delayOnTouchOnly: true,
      touchStartThreshold: 3,
      swapThreshold: 0.28,
      invertSwap: true,
      invertSwapThreshold: 0.85,
      ghostClass: 'tt-ghost',
      chosenClass: 'tt-chosen',
      dragClass: 'tt-drag',
      scroll: true,
      scrollSensitivity: 48,
      scrollSpeed: 12,
      bubbleScroll: true,

      onEnd: () => {
        // Reconstruct order by data-id (ignores fixed cells automatically)
        const order = sortable.toArray();
        const byId = new Map(items.map(t => [String(t.id), t]));
        const newArr = order.map(id => ({ ...byId.get(String(id)) }));

        // Resequence 1..N
        newArr.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
        setItems(newArr);
      },
    });

    return () => sortable.destroy();
  }, [containerRef, items, setItems]);
}

    function TileCard({ tile, onSelect, selected, marker, onDropEffect }) {
      const eff = EFFECTS.find(e => e.kind === tile.effect?.kind);
      const hasIcon = Boolean(tile.iconFile);
      const isStart = String(tile.id) === '1';

      return (
        React.createElement('div', { className: selected ? 'rounded-xl ring-2 ring-indigo-400' : '' },
          React.createElement('div', {
            className: 'tt-tile drag-handle',
            onClick: onSelect,
            tabIndex: 0,
            onDragOver: (e) => {
              if (e.dataTransfer.types.includes('text/tt-effect') || e.dataTransfer.types.includes('application/json')) {
                e.preventDefault();
                e.currentTarget.parentElement.classList.add('tt-drop-target');
              }
            },
            onDragLeave: (e) => {
              e.currentTarget.parentElement.classList.remove('tt-drop-target');
            },
            onDrop: (e) => {
              e.preventDefault();
              e.currentTarget.parentElement.classList.remove('tt-drop-target');
              let json = e.dataTransfer.getData('text/tt-effect') || e.dataTransfer.getData('application/json');
              if (!json) return;
              try {
                const eff = JSON.parse(json);
                if (!eff || typeof eff !== 'object') return;
                if (typeof onDropEffect === 'function') onDropEffect(eff);   // <- provided by parent
              } catch { }
            }
          },
        (marker && React.createElement('div', { className: `tt-marker ${marker === 'FINISH' ? 'finish' : ''}` }, marker)),
        React.createElement('div', { className: 'tt-tile-num' }, isStart ? '' : `#${tile.tileNumber}`),
        !isStart && hasIcon
              ? React.createElement('img', {
                src: tile.iconFile,
                className: 'tt-tile-icon',
                draggable: false,                      // prevent image-native ghost
                onError: (e) => { e.currentTarget.style.display = 'none'; }
              })
          : !isStart && React.createElement('div', { className: 'tt-tile-name' }, (tile.name || 'Untitled')),
        (!isStart && tile.effect && tile.effect.kind && tile.effect.kind !== 'none') &&
            React.createElement('div', { className: 'tt-tile-badge', title: tile.effect.kind },
              (tile.effect.kind || '').split('_').map(s => s[0]).join('').toUpperCase()
            )
          )
        )
      );
    }


    function EffectEditor({ tile, onChange }) {
      const eff = tile.effect || { kind: 'none' };
      const def = EFFECTS.find(e => e.kind === eff.kind) || EFFECTS[0];

      const update = (patch) => {
        const nextEff = { ...eff, ...patch };
        if (nextEff.kind === 'none') {
          return onChange({
            effect: { kind: 'none' },
            meta: { presetId: 'none', opts: {}, attached: false }
          });
        }
        const opts = {};
        if ('amount' in nextEff) opts.amount = Number(nextEff.amount);
        if ('index' in nextEff) opts.index = Number(nextEff.index);
        onChange({
          effect: nextEff,
          meta: { presetId: nextEff.kind, opts, attached: true }
        });
      };

      return (
        React.createElement('div', { className: 'space-y-3' },
          React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Effect'),
              React.createElement('select', {
                className: 'w-full rounded-lg border-slate-300',
                value: eff.kind || 'none',
                onChange: e => {
                  const nextKind = e.target.value;
                  const meta = EFFECTS.find(x => x.kind === nextKind) || EFFECTS[0];
                  update({
                    kind: nextKind,
                    trigger: nextKind === 'none' ? undefined : (meta.defaultTrigger || 'on_next_roll'),
                    amount: undefined,
                    index: undefined
                  });
                }
              }, EFFECTS.map(x => React.createElement('option', { key: x.kind, value: x.kind }, x.label)))
            ),
            (eff.kind !== 'none') && React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Trigger'),
              React.createElement('select', {
                className: 'w-full rounded-lg border-slate-300',
                value: eff.trigger || def.defaultTrigger || 'on_next_roll',
                onChange: e => update({ trigger: e.target.value })
              }, [
                React.createElement('option', { key: 'on_next_roll', value: 'on_next_roll' }, 'on_next_roll'),
                React.createElement('option', { key: 'on_land', value: 'on_land' }, 'on_land')
              ])
            )
          ),
          eff.kind === 'none'
            ? React.createElement('div', { className: 'text-xs text-slate-500' }, 'No effect will be applied for this tile.')
            : (def.params || []).map(p => React.createElement('div', { key: p.name },
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, p.name),
              React.createElement('input', {
                className: 'w-full rounded-lg border-slate-300',
                type: 'number', min: p.min, step: p.step || 1, placeholder: p.placeholder || '',
                value: eff[p.name] ?? '',
                onChange: (e) => update({ [p.name]: e.target.value === '' ? undefined : Number(e.target.value) })
              })
            )
            )
        )
      );
    }

    function EditorPanel({ tile, setTile, onDuplicate, onDelete }) {
      if (!tile) return React.createElement('div', { className: 'text-slate-500' }, 'Select a tile to edit.');
  const isStart = String(tile.id) === '1';

  if (isStart) {
    return React.createElement('div', { className: 'space-y-3' },
      React.createElement('div', { className: 'text-sm text-emerald-700 font-medium' }, 'START tile (fixed)'),
      React.createElement('p', { className: 'text-xs text-slate-600' }, 'This tile is fixed, cannot be dragged, and cannot have a name or effect.'),
      React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
        React.createElement('div', null,
          React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'ID'),
          React.createElement('input', { className: 'w-full rounded-lg border-slate-300 bg-slate-100 text-slate-500', value: tile.id, disabled: true, readOnly: true })
        ),
        React.createElement('div', null,
          React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Tile Number'),
          React.createElement('input', { className: 'w-full rounded-lg border-slate-300 bg-slate-100 text-slate-500', value: tile.tileNumber, disabled: true, readOnly: true })
        )
      )
    );
  }

      const update = (patch) => setTile({ ...tile, ...patch });

      return (
        React.createElement('div', { className: 'space-y-4' },
          React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'ID'),
              React.createElement('input', { className: 'w-full rounded-lg border-slate-300 bg-slate-100 text-slate-500', value: tile.id, disabled: true, readOnly: true })
            ),
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Tile Number'),
              React.createElement('input', { className: 'w-full rounded-lg border-slate-300', type: 'number', value: tile.tileNumber, onChange: e => update({ tileNumber: coerceNumber(e.target.value, tile.tileNumber) }) })
            )
          ),

          React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Name'),
            React.createElement('input', { className: 'w-full rounded-lg border-slate-300', value: tile.name, onChange: e => update({ name: e.target.value }) })
          ),
          React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Description'),
            React.createElement('textarea', { className: 'w-full rounded-lg border-slate-300', rows: 4, value: tile.desc, onChange: e => update({ desc: e.target.value }) })
          ),

          React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Icon URL (iconFile)'),
            React.createElement('input', { className: 'w-full rounded-lg border-slate-300', placeholder: 'https://...', value: tile.iconFile, onChange: e => update({ iconFile: e.target.value }) })
          ),

          React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-2' }, 'Effect'),
            React.createElement(EffectEditor, { tile, onChange: (patch) => update(patch) })
          ),

          React.createElement('div', { className: 'flex gap-2' },
            React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700', onClick: onDuplicate }, 'Duplicate'),
            React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-rose-600 text-white hover:bg-rose-700', onClick: onDelete }, 'Delete')
          )
        )
      );
    }

    function EffectBuilderPanel({ onBuild }) {
      const [kind, setKind] = useState('none');
      const [trigger, setTrigger] = useState('on_next_roll');
      const [amount, setAmount] = useState('');
      const [index, setIndex] = useState('');

      const meta = EFFECTS.find(e => e.kind === kind) || EFFECTS[0];
      const needsAmount = ['move_forward', 'move_back', 'double_next_roll', 'reverse_next_roll', 'shield_next_negative'].includes(kind) && meta.params.some(p => p.name === 'amount');
      const needsIndex = ['teleport_to'].includes(kind);

      const payload = {
        kind,
        ...(kind === 'none' ? {} : { trigger }),
        ...(amount !== '' ? { amount: Number(amount) } : {}),
        ...(index !== '' ? { index: Number(index) } : {}),
      };

      const onDragStart = (e) => {
        const text = JSON.stringify(payload);
        e.dataTransfer.setData('application/json', text);
        e.dataTransfer.setData('text/tt-effect', text);  // custom mime for safety
        e.dataTransfer.effectAllowed = 'copy';
      };

      return (
        React.createElement('div', { className: 'space-y-3' },
          React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Effect'),
              React.createElement('select', { className: 'w-full rounded-lg border-slate-300', value: kind, onChange: e => setKind(e.target.value) },
                EFFECTS.map(x => React.createElement('option', { key: x.kind, value: x.kind }, x.label))
              )
            ),
            (kind !== 'none') && React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Trigger'),
              React.createElement('select', { className: 'w-full rounded-lg border-slate-300', value: trigger, onChange: e => setTrigger(e.target.value) },
                [
                  React.createElement('option', { key: 'on_next_roll', value: 'on_next_roll' }, 'on_next_roll'),
                  React.createElement('option', { key: 'on_land', value: 'on_land' }, 'on_land'),
                ]
              )
            )
          ),
          (needsAmount) && React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'amount'),
            React.createElement('input', { className: 'w-full rounded-lg border-slate-300', type: 'number', min: 1, step: 1, value: amount, onChange: e => setAmount(e.target.value) })
          ),
          (needsIndex) && React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'index'),
            React.createElement('input', { className: 'w-full rounded-lg border-slate-300', type: 'number', min: 1, step: 1, value: index, onChange: e => setIndex(e.target.value) })
          ),
          React.createElement('div', { className: 'text-xs text-slate-500' }, 'Drag this token onto a tile to apply the effect:'),
          React.createElement('div', {
            className: 'tt-token',
            draggable: true,
            onDragStart,
            title: 'Drag onto a tile to apply'
          },
            React.createElement('span', { className: 'dot' }),
            React.createElement('span', null, kind === 'none' ? 'None (clear effect)' : `${kind}${amount !== '' ? ` amt=${amount}` : ''}${index !== '' ? ` idx=${index}` : ''}`)
          )
        )
      );
    }


    function Toolbar({ onNew, onClear, onImport, onExport, count }) {
      const fileRef = useRef(null);

      const triggerImport = () => fileRef.current && fileRef.current.click();

      const onFile = (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = () => onImport(String(reader.result || ''));
        reader.readAsText(f);
        e.target.value = '';
      }

      return (
        React.createElement('div', { className: 'flex flex-wrap items-center gap-2' },
          React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-emerald-600 text-white hover:bg-emerald-700', onClick: onNew }, 'Add Tile'),
          React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-slate-200 text-slate-800 hover:bg-slate-300', onClick: onClear }, 'Clear'),
          React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-sky-600 text-white hover:bg-sky-700', onClick: triggerImport }, 'Import JSON'),
          React.createElement('input', { ref: fileRef, type: 'file', accept: '.json,application/json', className: 'hidden', onChange: onFile }),
          React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700', onClick: onExport }, 'Export JSON'),
          React.createElement('div', { className: 'ml-auto text-sm text-slate-600' }, `${count} tile${count === 1 ? '' : 's'}`)
        )
      );
    }
function buildSnakePositions(count, ROW_LEN = 15) {
  const positions = [];
  let x = 0, y = 0, dir = 1;

  for (let i = 0; i < count;) {
    // Horizontal run
    for (let h = 0; h < ROW_LEN && i < count; h++, i++) {
      positions.push({ x, y, type: 'h', hIndex: h, rowIndex: Math.floor(positions.length / ROW_LEN) });
      if (h < ROW_LEN - 1 && i < count) x += dir;
    }
    // Vertical drop
    if (i < count) {
      y++;
      positions.push({ x, y, type: 'drop' });
      i++;
    }
    // Next row
    dir *= -1;
    y++;
  }
  return positions;
}

    function buildSnakePositionsWithStart(countTiles, rowLen = 15) {
      const total = countTiles + 1; // +1 for START
      const positions = [];
      let x = 0, y = 0, dir = 1;

      // START at (0,0)
      positions.push({ x, y, type: 'start' });

      // Move to first tile slot to the right of START for horizontal run
      if (total > 1) {
        x += 1;
        // Fill remaining slots
        for (let placed = 1; placed < total;) {
          // Horizontal run (rowLen - 1 because START already used one column on the very first row)
          const run = positions.length === 1 ? (rowLen - 1) : rowLen;
          for (let h = 0; h < run && placed < total; h++, placed++) {
            positions.push({ x, y, type: 'h', hIndex: h });
            if (h < run - 1 && placed < total) x += dir;
          }
          if (placed >= total) break;
          // Vertical drop (one tile directly below current end)
          y += 1; placed++;
          positions.push({ x, y, type: 'drop' });
          if (placed >= total) break;

          // Flip direction and move to next horizontal row start
          dir *= -1;
          y += 1;
          // Move to row start x
          x += dir * (rowLen - 1);
        }
      }
      return positions;
    }

function PreviewGrid({ tiles, onSelect, selectedId, setTiles }) {
  const listRef = React.useRef(null);
  const ROW_LEN = 15;

  // Build positions for ALL playable tiles (1..N)
  const positions = React.useMemo(
    () => buildSnakePositions(tiles.length, ROW_LEN),
    [tiles.length]
  );

  // Identify first-of-row (horizontal) positions AFTER the first row
  const rowStartFlags = React.useMemo(() => {
    const flags = new Array(tiles.length).fill(false);
    let seenRows = 0;
    // A horizontal row starts when type==='h' && hIndex===0
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      if (p.type === 'h' && p.hIndex === 0) {
        // skip the very first horizontal row (no "ROW 1" label)
        if (seenRows > 0) {
          // map back to tile index: positions index == tile index for horizontals & drops
          flags[i] = true;
        }
        seenRows++;
      }
    }
    return flags;
  }, [positions]);

  // Sortable (exclude first tile from dragging by CSS class)
  useSortable(listRef, tiles, (newArr) => {
    // Reorder by DOM and resequence 1..N
    newArr.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
    setTiles(newArr.slice());
  });

  const cellStyleFor = (i) => {
    const p = positions[i];
    return { gridColumn: (p.x + 1), gridRow: (p.y + 1) };
  };

  return (
    React.createElement(
      'div',
      {
        ref: listRef,
        className: 'tt-grid',
        style: { gridTemplateColumns: `repeat(${ROW_LEN}, var(--tile))` },
      },
      tiles.map((t, i) => {
        // Markers: START on first tile, FINISH on last; ROW labels on subsequent horizontal rows
        let marker = null;
        if (i === 0) marker = 'START';
        else if (i === tiles.length - 1) marker = 'FINISH';
        else if (rowStartFlags[i]) {
          // Compute visible row # (1st horizontal row had no label)
          const rowsBefore = rowStartFlags.slice(0, i + 1).filter(Boolean).length;
          marker = `ROW ${rowsBefore + 1}`; // â€œROW 2â€, â€œROW 3â€, â€¦
        }

        return React.createElement(
          'div',
          {
            key: t.id,
            'data-id': t.id,
            className: `tt-cell ${i === 0 ? 'tt-fixed' : ''}`, // first tile is fixed
            style: cellStyleFor(i),
          },
          React.createElement(TileCard, {
            tile: t,
            onSelect: () => onSelect(t.id),
            selected: t.id === selectedId,
            marker,
            // when index 0 (START), TileCard will also render with editing/drag disabled
          })
        );
      })
    )
  );
}
    function BoardSettings({ count }) {
      const rows = Math.ceil(count / 15);
      return React.createElement('div', { className: 'flex flex-wrap items-center gap-4' },
        React.createElement('div', null,
          React.createElement('div', { className: 'text-sm text-slate-700' }, 'Columns: 15 (fixed)')
        ),
        React.createElement('div', null,
          React.createElement('div', { className: 'text-sm text-slate-700' }, 'Path: Snake (always on)')
        ),
        React.createElement('div', { className: 'ml-auto text-sm text-slate-600' }, `Rows: ${rows}`)
      );
    }

    function App() {
      const applyEffectToTile = (tileId, eff) => {
        setTiles(prev => prev.map(t => {
          if (t.id !== tileId) return t;
          if (!eff || eff.kind === 'none') {
            return { ...t, effect: { kind: 'none' }, meta: { presetId: 'none', opts: {}, attached: false } };
          }
          const opts = {};
          if ('amount' in eff) opts.amount = Number(eff.amount);
          if ('index' in eff) opts.index = Number(eff.index);
          return {
            ...t,
            effect: { ...eff },
            meta: { presetId: eff.kind, opts, attached: true }
          };
        }));
      };
      const [tiles, setTiles] = useState(() => {
        try {
          const saved = JSON.parse(localStorage.getItem('tt-editor-tiles') || 'null');
          if (Array.isArray(saved) && saved.length) return saved;
        } catch { }
        return Array.from({ length: 10 }, (_, i) => makeDefaultTile(i + 1));
      });
      const cols = 15;
      const snake = true;
      const [selectedId, setSelectedId] = useState(tiles[0]?.id || null);

      useEffect(() => { localStorage.setItem('tt-editor-tiles', JSON.stringify(tiles)); }, [tiles]);
      useEffect(() => { localStorage.setItem('tt-editor-snake', snake ? '1' : '0'); }, [snake]);

      const selectedTile = useMemo(() => tiles.find(t => t.id === selectedId) || null, [tiles, selectedId]);

      const replaceTile = (next) => {
        setTiles(prev => prev.map(t => t.id === next.id ? next : t).sort((a, b) => a.tileNumber - b.tileNumber).map((t, i) => ({ ...t, tileNumber: i + 1, id: String(i + 1) })));
      };

      const addTile = () => {
        setTiles(prev => {
          const n = prev.length + 1;
          const t = makeDefaultTile(n);
          return [...prev, t];
        });
        setSelectedId(prev => null);
      };

      const clearAll = () => {
        if (confirm('Clear all tiles?')) {
          setTiles([]);
          setSelectedId(null);
        }
      };

      const importJSON = (text) => {
        try {
          const raw = JSON.parse(text);
          const extracted = extractTilesFromAny(raw);
          if (!Array.isArray(extracted) || !extracted.length) {
            alert('No tiles found in JSON.'); return;
          }
          const norm = normalizeImportedTiles(extracted);
          setTiles(norm);
          setSelectedId(norm[0]?.id || null);
        } catch (e) {
          alert('Invalid JSON: ' + e.message);
        }
      };

      const exportJSON = () => {
        const out = tiles.map(t => {
          const eff = t.effect || null;
          const isNone = !eff || eff.kind === 'none';
          const metaOpts = {};
          if (eff && 'amount' in eff) metaOpts.amount = eff.amount;
          if (eff && 'index' in eff) metaOpts.index = eff.index;

          const obj = {
            id: String(t.id),
            tileNumber: Number(t.tileNumber),
            name: t.name || '',
            desc: t.desc || '',
            iconFile: t.iconFile || ''
          };

          obj.effect = isNone ? null : { ...eff };
          if (!isNone) obj.meta = { presetId: eff.kind || 'move_forward', opts: metaOpts, attached: true };

          return obj;
        });
        const text = JSON.stringify(out, null, 2);
        download('board.json', text);
      };

      const duplicateSelected = () => {
        if (!selectedTile) return;
        const copy = JSON.parse(JSON.stringify(selectedTile));
        delete copy.id;
        setTiles(prev => {
          const idx = prev.findIndex(t => t.id === selectedTile.id);
          const next = prev.slice();
          next.splice(idx + 1, 0, copy);
          next.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
          return next;
        });
      };

      const deleteSelected = () => {
        if (!selectedTile) return;
        if (!confirm('Delete this tile?')) return;
        setTiles(prev => {
          const next = prev.filter(t => t.id !== selectedTile.id);
          next.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
          return next;
        });
        setSelectedId(null);
      };

      return (
        React.createElement('div', { className: 'max-w-7xl mx-auto p-6 space-y-6' },
          React.createElement('header', { className: 'flex items-center gap-3' },
            React.createElement('div', { className: 'w-10 h-10 rounded-xl bg-indigo-600 text-white grid place-items-center font-bold' }, 'TT'),
            React.createElement('div', null,
              React.createElement('h1', { className: 'text-xl font-semibold text-slate-900' }, 'TileTrials Board Editor'),
              React.createElement('p', { className: 'text-slate-600 text-sm' }, 'Drag, edit, and export a board.json compatible with your /tiletrials importboard command.')
            )
          ),

          React.createElement('div', { className: 'rounded-2xl bg-white shadow-soft border border-slate-200 p-4' },
            React.createElement(Toolbar, { onNew: addTile, onClear: clearAll, onImport: importJSON, onExport: exportJSON, count: tiles.length })
          ),

          React.createElement('div', { className: 'rounded-2xl bg-white shadow-soft border border-slate-200 p-4' },
            React.createElement(BoardSettings, { count: tiles.length })
          ),

          React.createElement('div', { className: 'tt-layout' },
            // Left: Board area
            React.createElement('div', { className: 'space-y-3' },
              React.createElement('div', { className: 'tt-board-wrap' },
                React.createElement(PreviewGrid, { tiles, onSelect: setSelectedId, selectedId, setTiles })
              ),
              React.createElement('div', { className: 'text-xs text-slate-500' }, 'Tip: drag a tile to reorder. Export to download the JSON.')
            ),

            // Right: Editor
            React.createElement('aside', { className: 'rounded-2xl bg-white shadow-soft border border-slate-200 p-4 space-y-6' },
              React.createElement('div', null,
                React.createElement('h2', { className: 'text-sm font-semibold text-slate-700 mb-3' }, 'Tile Editor'),
                React.createElement(EditorPanel, {
                  tile: selectedTile,
                  setTile: replaceTile,
                  onDuplicate: duplicateSelected,
                  onDelete: deleteSelected
                })
              ),
              React.createElement('div', null,
                React.createElement('h2', { className: 'text-sm font-semibold text-slate-700 mb-3' }, 'Effect Builder'),
                React.createElement(EffectBuilderPanel, null)
              )
            )
          ),

          React.createElement('footer', { className: 'text-center text-xs text-slate-500 pt-2' }, 'Made for GitHub Pages â€” no backend required.')
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App));
  </script>
</body>

</html>

<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TileTrials Board Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          boxShadow: {
            soft: "0 8px 30px rgba(0,0,0,0.08)",
          }
        }
      }
    }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Fonts */
    @font-face {
      font-family: 'RuneScape-Quill';
      src: url('assets/font/RuneScape-Quill.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    html,
    body {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: url('assets/images/bg.png') center / cover fixed no-repeat;
      min-height: 100vh;
    }

    :root {
      --tile: 84px;
      --bronze: #cd7f32;
      --bronze-dark: #8a531e;
      --ink: #2c1a0e;
    }

    .drag-handle {
      cursor: grab;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .scrollbar-thin::-webkit-scrollbar {
      height: 8px;
      width: 8px;
    }

    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 9999px;
    }

    /* Tile look: parchment fill + bronze frame to mimic renderer */
    .tt-tile {
      position: relative;
      width: var(--tile);
      height: var(--tile);
      background: url('assets/images/parchment.png') center / cover no-repeat;
      border: 3px solid var(--bronze);
      border-radius: 6px;
      box-shadow:
        0 2px 2px rgba(0, 0, 0, 0.45),
        inset 0 0 0 1.5px var(--bronze-dark),
        inset 0 6px 10px rgba(255, 255, 255, 0.22);
      transition: transform .06s ease;
    }

    .tt-tile:hover {
      transform: translateY(-1px);
    }

    .tt-tile-num {
      position: absolute;
      top: 4px;
      right: 4px;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      font-size: 14px;
      color: var(--ink);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.85);
      letter-spacing: .3px;
      user-select: none;
    }

    .tt-tile-icon {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: calc(var(--tile) * .72);
      height: calc(var(--tile) * .72);
      object-fit: contain;
      background: rgba(0, 0, 0, 0.08);
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
    }

    .tt-tile-name {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      max-width: calc(var(--tile) * .86);
      text-align: center;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      color: var(--ink);
      text-shadow: 0 1px 0 rgba(0, 0, 0, .85);
      font-size: 13px;
      line-height: 1.05;
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tt-tile-badge {
      position: absolute;
      left: 6px;
      bottom: 6px;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.55);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
      display: grid;
      place-items: center;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      color: #ffd166;
      font-size: 11px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .85);
      user-select: none;
    }

    /* Each grid cell = exactly one tile */
    .tt-cell {
      width: var(--tile);
      height: var(--tile);
      position: relative;
      transition: transform .16s cubic-bezier(.2, .7, .2, 1), box-shadow .16s cubic-bezier(.2, .7, .2, 1);
    }

    .tt-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 16px;
    }

    @media (max-width: 1024px) {
      .tt-layout {
        grid-template-columns: 1fr;
      }
    }

    .tt-board-wrap {
      position: relative;
      overflow: auto;
      /* keep vertical scroll if tall */
      overflow-x: hidden;
      /* prevent horizontal scroll */
      padding: 8px;
      background: rgba(255, 255, 255, 0.35);
      border: 1px solid rgba(0, 0, 0, 0.06);
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(2px);

      /* cap to 15 rows (15 tiles + 14 gaps + padding) */
      max-height: calc((var(--tile) * 15) + (12px * 14) + 24px);

      display: flex;
      /* ‚üµ center the grid */
      justify-content: center;
    }

    /* Keep the visual wrapper the same size as the tile while we fix offset */
    .tt-card {
      width: var(--tile);
      padding: 0;
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .tt-id {
      font-size: 11px;
      color: rgba(0, 0, 0, 0.55);
      margin-left: auto;
    }

    .tt-grid {
      display: grid;
      grid-auto-rows: var(--tile);
      grid-auto-flow: row dense;
      align-content: start;
      justify-content: start;
      /* grid content starts at col 1 */
      gap: 12px;

      /* Center + scale to fit (hook below sets transform) */
      margin-inline: auto;
      transform-origin: top center;
    }

    /* Start/Finish marker badges */
    .tt-marker {
      position: absolute;
      top: 6px;
      left: 6px;
      background: linear-gradient(180deg, #22c55e, #16a34a);
      color: #fff;
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
      user-select: none;
    }

    .tt-marker.finish {
      background: linear-gradient(180deg, #f59e0b, #b45309);
    }

    /* Prevent selection/drag ghost blue marquee while dragging */
    .tt-board-wrap,
    .tt-grid,
    .tt-cell,
    .tt-tile,
    .tt-tile * {
      -webkit-user-select: none;
      user-select: none;
    }

    /* Prevent browser focus outlines on the tile itself */
    .tt-tile:focus,
    .tt-tile:focus-visible {
      outline: none;
    }

    /* Prevent image-native drag ghost */
    .tt-tile img {
      -webkit-user-drag: none;
    }

    .tt-ghost .tt-tile {
      visibility: hidden;
    }

    .tt-chosen .tt-tile {
      transform: scale(1.04);
      box-shadow: 0 10px 18px rgba(0, 0, 0, .25), inset 0 0 0 1.5px rgba(0, 0, 0, .25);
    }

    .tt-drag {
      opacity: .98;
      cursor: grabbing !important;
      transition: none;
    }

    .tt-drag .tt-tile {
      transform: scale(1.02);
      /* subtle */
      box-shadow: 0 8px 12px rgba(0, 0, 0, .20), inset 0 0 0 1px rgba(0, 0, 0, .2);
    }

    .tt-start .tt-tile {
      background: url('assets/images/parchment.png') center / cover no-repeat;
      border-color: #22c55e;
      box-shadow:
        0 2px 2px rgba(0, 0, 0, .45),
        inset 0 0 0 1.5px #15803d,
        inset 0 6px 10px rgba(255, 255, 255, .22);
    }

    .tt-start .tt-tile .tt-tile-num {
      display: none;
    }

    .tt-start .tt-tile-name {
      font-size: 14px;
      color: #14532d;
    }

    /* Drop highlight for tiles when dragging an effect token */
    .tt-drop-target .tt-tile {
      outline: 2px dashed rgba(34, 197, 94, .9);
      outline-offset: 2px;
    }

    /* Effect token look */
    .tt-token {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, .05);
      border: 1px solid rgba(0, 0, 0, .12);
      border-radius: 10px;
      font-size: 12px;
      cursor: grab;
    }

    .tt-token:active {
      cursor: grabbing;
    }

    .tt-token .dot {
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      background: #0ea5e9;
    }

    .tt-eff {
      position: absolute;
      left: 6px;
      bottom: 6px;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.55);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    .tt-eff img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    /* Fallback 2-letter badge if icon missing */
    .tt-eff-fallback {
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      color: #ffd166;
      font-size: 11px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .85);
    }

    /* Token with icon */
    .tt-token img {
      width: 16px;
      height: 16px;
      object-fit: contain;
      display: block;
      border-radius: 4px;
    }

    .panel-medieval {
      position: relative;
      background: url('assets/images/parchment.png') center/cover no-repeat, rgba(250, 245, 230, 0.86);
      border: 3px solid #cd7f32;
      /* bronze */
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .12), inset 0 0 0 1.5px #8a531e;
      overflow: hidden;
    }

    .panel-medieval::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at top, rgba(255, 255, 255, .25), transparent 60%),
        radial-gradient(ellipse at bottom, rgba(0, 0, 0, .08), transparent 60%);
      pointer-events: none;
    }

    /* Section heading in RuneScape-Quill */
    .heading-medieval {
      font-family: 'RuneScape-Quill', Inter, ui-sans-serif;
      letter-spacing: .3px;
      color: #2c1a0e;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .35);
    }

    /* Bronze button */
    .btn-bronze {
      background: linear-gradient(180deg, #d8a25e, #b0792e);
      color: #1b1108;
      border: 1px solid #8a531e;
      border-radius: 10px;
      padding: 8px 12px;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .2), inset 0 0 0 1px rgba(255, 255, 255, .25);
      transition: transform .06s ease, box-shadow .12s ease;
    }

    .btn-bronze:hover {
      transform: translateY(-1px);
    }

    .btn-bronze:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(0, 0, 0, .2);
    }

    /* Secondary "stone" button */
    .btn-stone {
      background: linear-gradient(180deg, #e5e7eb, #cbd5e1);
      color: #111827;
      border: 1px solid #9ca3af;
      border-radius: 10px;
      padding: 8px 12px;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .1), inset 0 0 0 1px rgba(255, 255, 255, .25);
      transition: transform .06s ease, box-shadow .12s ease;
    }

    .btn-stone:hover {
      transform: translateY(-1px);
    }

    .editor-prose,
    .editor-prose * {
      color: #000 !important;
      text-shadow: 1px 0px 1px rgba(255, 255, 255, 0.4);
    }
  </style>
</head>

<body class="bg-slate-50">
  <div id="root"></div>

  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

  <script>
    const { useState, useMemo, useEffect, useRef } = React;

    // All supported effects and their suggested default trigger/params
    const EFFECTS = [
      { kind: 'none', label: 'None (no effect)', defaultTrigger: null, params: [] },
      { kind: 'move_forward', label: 'Move Forward', defaultTrigger: 'on_next_roll', params: [{ name: 'amount', type: 'number', min: 1, step: 1, placeholder: 'e.g. 2' }] },
      { kind: 'move_back', label: 'Move Back', defaultTrigger: 'on_next_roll', params: [{ name: 'amount', type: 'number', min: 1, step: 1, placeholder: 'e.g. 1' }] },
      { kind: 'teleport_to', label: 'Teleport To (index)', defaultTrigger: 'on_next_roll', params: [{ name: 'index', type: 'number', min: 1, step: 1, placeholder: 'tile index' }] },
      { kind: 'go_to_start', label: 'Go To START', defaultTrigger: 'on_land', params: [] },
      { kind: 'set_checkpoint', label: 'Set Checkpoint', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'go_to_checkpoint', label: 'Go To Checkpoint', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'reverse_next_roll', label: 'Reverse Next Roll', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'double_next_roll', label: 'Double Next Roll', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'shield_next_negative', label: 'Shield Next Negative', defaultTrigger: 'on_next_roll', params: [] },
      { kind: 'swap_with_random_team', label: 'Swap with Random Team', defaultTrigger: 'on_land', params: [] },
      { kind: 'swap_with_leader', label: 'Swap with Leader', defaultTrigger: 'on_land', params: [] },
    ];

    const DEFAULT_ICON = 'https://cdn.jsdelivr.net/gh/tabler/tabler-icons@latest/icons/outlet.svg';

    const WIKI_API = 'https://oldschool.runescape.wiki/api.php';

    function download(filename, text) {
  const blob = new Blob([text], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

// Small backoff for 429s (retry once)
async function backoffFetch(url, opts = {}, tries = 2) {
  let last;
  for (let i = 0; i < tries; i++) {
    const res = await fetch(url, opts).catch(e => (last = e, null));
    if (!res) continue;
    if (res.status !== 429) return res;
    const retryAfter = Number(res.headers.get('retry-after')) || 0;
    const wait = retryAfter ? retryAfter * 1000 : (600 + Math.random() * 600);
    await new Promise(r => setTimeout(r, wait));
  }
  throw last || new Error('Rate limited by OSRS Wiki');
}

// Session memo to avoid refetching
const WIKI_MEMO = new Map();          // filename-level memo: `ii|width|name` -> { fileUrl, thumbUrl }
const WIKI_QUERY_MEMO = new Map();    // query-level memo: `ai|prefix|width` -> [{ name, fileUrl, thumbUrl }]

// Resolve file metadata (thumb + original) for many files in one POST
async function wikiGetImageInfo(fileNames, width = 192) {
  const results = [];
  for (let i = 0; i < fileNames.length; i += 40) {
    const chunk = fileNames.slice(i, i + 40);
    const toFetch = [];
    const cached = [];

    for (const name of chunk) {
      const k = `ii|${width}|${name}`;
      const hit = WIKI_MEMO.get(k);
      if (hit) cached.push({ name, ...hit });
      else toFetch.push(name);
    }

    if (toFetch.length) {
      const body = new URLSearchParams({
        action: 'query',
        format: 'json',
        origin: '*',
        prop: 'imageinfo',
        iiprop: 'url',
        iiurlwidth: String(width),
        maxage: '86400',
        smaxage: '86400',
        titles: toFetch.map(n => `File:${n}`).join('|'),
      });

      const res = await backoffFetch(WIKI_API, { method: 'POST', body });
      const json = await res.json();
      const pages = json?.query?.pages || {};
      for (const p of Object.values(pages)) {
        const title = (p.title || '').replace(/^File:/, '');
        const ii = (p.imageinfo && p.imageinfo[0]) || {};
        const rec = { name: title, fileUrl: ii.url || '', thumbUrl: ii.thumburl || ii.url || '' };
        results.push(rec);
        if (title) WIKI_MEMO.set(`ii|${width}|${title}`, { fileUrl: rec.fileUrl, thumbUrl: rec.thumbUrl });
      }
    }

    results.push(...cached);
  }
  return results;
}

// Search by case-insensitive file title prefix, then enrich with imageinfo (thumbs at 192px)
async function wikiSearchFiles(prefix, limit = 40, thumbWidth = 192) {
  const q = (prefix || '').trim();
  if (q.length < 2) return [];

  const memoKey = `ps|${q}|${thumbWidth}`;
  if (WIKI_QUERY_MEMO.has(memoKey)) return WIKI_QUERY_MEMO.get(memoKey);

  // 1) Primary: prefixsearch on File namespace (6) ‚Äî case-insensitive title prefix
  const qsPS = new URLSearchParams({
    action: 'query',
    format: 'json',
    origin: '*',
    list: 'prefixsearch',
    pssearch: q,
    psnamespace: '6',                // File:
    pslimit: String(Math.min(limit, 50)),
    maxage: '86400',
    smaxage: '86400',
  });

  let names = [];
  try {
    const res = await backoffFetch(`${WIKI_API}?${qsPS.toString()}`);
    const json = await res.json().catch(() => ({}));
    names = (json?.query?.prefixsearch || [])
      .map(p => (p.title || '').replace(/^File:/, ''))
      .filter(Boolean);
  } catch {}

  // 2) Fallback: allimages (helps if prefixsearch returns nothing for some rare inputs)
  if (!names.length) {
    const qsAI = new URLSearchParams({
      action: 'query',
      format: 'json',
      origin: '*',
      list: 'allimages',
      aiprefix: q[0].toUpperCase() + q.slice(1),  // nudge case
      ailimit: String(Math.min(limit, 50)),
      maxage: '86400',
      smaxage: '86400',
    });
    try {
      const resAI = await backoffFetch(`${WIKI_API}?${qsAI.toString()}`);
      const jsonAI = await resAI.json().catch(() => ({}));
      names = (jsonAI?.query?.allimages || [])
        .map(img => img.name || (img.title || '').replace(/^File:/, ''))
        .filter(Boolean);
    } catch {}
  }

  const info = names.length ? await wikiGetImageInfo(names, thumbWidth) : [];
  WIKI_QUERY_MEMO.set(memoKey, info);
  return info; // [{ name, fileUrl, thumbUrl }]
}

    function nanoid(size = 8) {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let s = '';
      for (let i = 0; i < size; i++) s += chars[Math.floor(Math.random() * chars.length)];
      return s;
    }

    function useFitScale(gridRef, cols = 15) {
      React.useEffect(() => {
        if (!gridRef.current) return;
        const el = gridRef.current;
        const parent = el.parentElement;

        const compute = () => {
          const root = getComputedStyle(document.documentElement);
          const tile = parseFloat(root.getPropertyValue('--tile')) || 84;
          const gap = 12; // must match .tt-grid gap
          const full = cols * tile + (cols - 1) * gap;    // full pixel width of 15 columns
          const avail = parent.clientWidth - 8 * 2;       // 8px padding on each side
          const scale = Math.max(0.5, Math.min(1, avail / full)); // clamp 0.5..1 for readability
          el.style.transform = `scale(${scale})`;
          el.setAttribute('data-scale', String(scale));
        };

        const ro = new ResizeObserver(compute);
        ro.observe(parent);
        compute();
        return () => ro.disconnect();
      }, [gridRef, cols]);
    }

    function useAutoCols(maxCols = 15) {
      const gridRef = React.useRef(null);
      const [cols, setCols] = React.useState(1);

      React.useEffect(() => {
        if (!gridRef.current) return;

        const el = gridRef.current;

        const compute = () => {
          // Read CSS --tile and gap to estimate how many columns fit
          const root = getComputedStyle(document.documentElement);
          const tile = parseFloat(root.getPropertyValue('--tile')) || 84;
          const gap = 12; // keep in sync with .tt-grid gap
          const width = el.clientWidth; // visible width of grid container
          // columns = floor((width + gap) / (tile + gap)), clamped 1..maxCols
          const perRow = Math.max(1, Math.min(maxCols, Math.floor((width + gap) / (tile + gap))));
          setCols(perRow);
        };

        // ResizeObserver to track container width
        const ro = new ResizeObserver(() => compute());
        ro.observe(el);

        // First compute now (in case observer fires late)
        compute();

        return () => ro.disconnect();
      }, [maxCols]);

      return [gridRef, cols];
    }

    function getEffectIconUrl(kind) {
      if (!kind || kind === 'none') return null;
      return `assets/images/sstatuseffects/${kind}.png`;
    }

    function makeDefaultTile(n) {
      return {
        id: String(n),
        tileNumber: n,
        name: `Tile ${n}`,
        desc: '',
        iconFile: '',
        effect: { kind: 'none' },
        meta: { presetId: 'none', opts: {}, attached: false }
      };
    }

    function coerceNumber(v, fallback) {
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    }

    // Extract tiles from different shapes
    function extractTilesFromAny(raw) {
      try {
        if (Array.isArray(raw)) return raw;
        if (Array.isArray(raw?.tiles)) return raw.tiles;
        if (Array.isArray(raw?.board?.tiles)) return raw.board.tiles;
        if (raw && (raw.tileNumber || raw.name || raw.desc)) return [raw];
        if (raw && typeof raw === 'object') {
          const entries = Object.entries(raw);
          if (entries.every(([k, v]) => v && typeof v === 'object')) {
            return entries.map(([k, v]) => ({ id: v.id ?? k, tileNumber: v.tileNumber ?? Number(k), ...v }));
          }
        }
      } catch { }
      return [];
    }

    function normalizeImportedTiles(list) {
      const tiles = [];
      for (let i = 0; i < list.length; i++) {
        const t = list[i] || {};
        const num = coerceNumber(t.tileNumber ?? t.id ?? i + 1, i + 1);
        const id = String(t.id ?? num);

        // Accept multiple icon field names
        const icon =
          t.iconFile ?? t.iconUrl ?? t.iconURL ?? t.icon ?? t.icon_link ?? t.iconLink ?? '';

        // Treat missing OR empty OR 'none' effect as none
        const rawEff = t.effect;
        const hasEff =
          rawEff &&
          typeof rawEff === 'object' &&
          typeof rawEff.kind === 'string' &&
          rawEff.kind !== 'none' &&
          rawEff.kind.trim() !== '';

        let effect, meta;
        if (!hasEff) {
          effect = { kind: 'none' };
          meta = { presetId: 'none', opts: {}, attached: false };
        } else {
          const kind = String(rawEff.kind).trim();
          const def = EFFECTS.find(e => e.kind === kind);
          const trigger = rawEff.trigger || def?.defaultTrigger || 'on_next_roll';

          const obj = { kind, trigger };
          if ('amount' in rawEff) obj.amount = coerceNumber(rawEff.amount, 1);
          if ('index' in rawEff) obj.index = coerceNumber(rawEff.index, 1);

          const opts = {};
          if ('amount' in obj) opts.amount = obj.amount;
          if ('index' in obj) opts.index = obj.index;

          effect = obj;
          meta = { presetId: kind, opts, attached: true };
        }

        tiles.push({
          id,
          tileNumber: num,
          name: String(t.name ?? `Tile ${num}`),
          desc: String(t.desc ?? ''),
          iconFile: String(icon),
          effect,
          meta,
        });
      }

      // Sort and resequence IDs/indices 1..N
      tiles.sort((a, b) => a.tileNumber - b.tileNumber);
      tiles.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
      return tiles;
    }

    // Scale the percent of effected tiles by board size
    // <20 tiles ‚Üí ~5‚Äì12% ; 20‚Äì60 ‚Üí ~12‚Äì22% ; >60 ‚Üí ~22‚Äì30%
    function effectTargetCount(playableCount) {
      if (playableCount <= 0) return 0;
      const pct =
        playableCount < 20
          ? 0.05 + Math.random() * 0.07
          : playableCount < 60
            ? 0.12 + Math.random() * 0.10
            : 0.22 + Math.random() * 0.08;
      return Math.max(1, Math.round(playableCount * pct));
    }

    function randomInt(min, max) {
      const lo = Math.ceil(Math.min(min, max));
      const hi = Math.floor(Math.max(min, max));
      return Math.floor(Math.random() * (hi - lo + 1)) + lo;
    }

    function buildRandomEffect(kind, playableCount) {
      const def = EFFECTS.find(e => e.kind === kind);
      const trigger = def?.defaultTrigger || 'on_next_roll';
      switch (kind) {
        case 'move_forward':
          return { kind, trigger, amount: randomInt(1, Math.max(2, Math.floor(playableCount * 0.10))) };
        case 'move_back':
          return { kind, trigger, amount: randomInt(1, Math.max(1, Math.floor(playableCount * 0.08))) };
        case 'teleport_to':
          return { kind, trigger, index: Math.max(1, Math.min(playableCount, randomInt(1, playableCount))) };
        case 'double_next_roll':
        case 'reverse_next_roll':
        case 'shield_next_negative':
          return { kind, trigger, amount: 1 };
        case 'set_checkpoint':
        case 'go_to_checkpoint':
        case 'go_to_start':
        case 'swap_with_random_team':
        case 'swap_with_leader':
          return { kind, trigger };
        default:
          return { kind: 'none' };
      }
    }

    function useSortable(containerRef, items, setItems) {
      const { useEffect } = React;

      useEffect(() => {
        if (!containerRef.current) return;

        const el = containerRef.current;
        const sortable = new Sortable(el, {
          dataIdAttr: 'data-id',
          draggable: '.tt-cell:not(.tt-fixed)',  // ignore fixed first tile
          handle: '.tt-tile',
          animation: 90,
          easing: 'cubic-bezier(.2,.7,.2,1)',
          forceFallback: true,
          fallbackOnBody: true,
          fallbackTolerance: 2,
          delayOnTouchOnly: true,
          touchStartThreshold: 3,
          swapThreshold: 0.28,
          invertSwap: true,
          invertSwapThreshold: 0.85,
          ghostClass: 'tt-ghost',
          chosenClass: 'tt-chosen',
          dragClass: 'tt-drag',
          scroll: true,
          scrollSensitivity: 48,
          scrollSpeed: 12,
          bubbleScroll: true,

          onEnd: () => {
            // 1) Read actual DOM order of ALL cells (fixed + draggables)
            const nodes = Array.from(el.querySelectorAll('.tt-cell'));
            const idsInDom = nodes
              .map(n => n.getAttribute('data-id'))
              .filter(Boolean);

            // 2) Ensure the fixed first tile stays first
            const fixedId = String(items[0]?.id);
            const unique = Array.from(new Set(idsInDom));          // de-dupe just in case
            const withoutFixed = unique.filter(id => id !== fixedId);
            const finalIds = [fixedId, ...withoutFixed];

            // 3) Rebuild array from ids (fallback to old items if something is missing)
            const byId = new Map(items.map(t => [String(t.id), t]));
            const newArr = finalIds
              .map(id => byId.get(String(id)))
              .filter(Boolean);

            // If for any reason lengths mismatch, bail out safely
            if (!newArr.length || newArr.length !== items.length) {
              console.warn('Sortable reorder mismatch; preserving previous order');
              return;
            }

            // 4) Resequence 1..N
            newArr.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });

            setItems(newArr);
          },
        });

        return () => sortable.destroy();
      }, [containerRef, items, setItems]);
    }
    function TileCard({ tile, onSelect, selected, marker, onDropEffect }) {
      const kind = tile.effect?.kind || 'none';
      const iconUrl = getEffectIconUrl(kind);
      const hasIcon = Boolean(tile.iconFile);
      const isStart = String(tile.id) === '1';

      const canDrop = !isStart; // ‚Üê guard

      return (
        React.createElement('div', { className: selected ? 'rounded-xl ring-2 ring-indigo-400' : '' },
          React.createElement('div', {
            className: 'tt-tile drag-handle',
            onClick: onSelect,
            tabIndex: 0,

            onDragOver: (e) => {
              if (!canDrop) return;                       // ‚Üê guard
              if (e.dataTransfer.types.includes('text/tt-effect') || e.dataTransfer.types.includes('application/json')) {
                e.preventDefault();
                e.currentTarget.parentElement.classList.add('tt-drop-target');
              }
            },
            onDragLeave: (e) => {
              if (!canDrop) return;                       // ‚Üê guard
              e.currentTarget.parentElement.classList.remove('tt-drop-target');
            },
            onDrop: (e) => {
              if (!canDrop) return;                       // ‚Üê guard
              e.preventDefault();
              e.currentTarget.parentElement.classList.remove('tt-drop-target');
              let json = e.dataTransfer.getData('text/tt-effect') || e.dataTransfer.getData('application/json');
              if (!json) return;
              try {
                const eff = JSON.parse(json);
                if (!eff || typeof eff !== 'object') return;
                if (typeof onDropEffect === 'function') onDropEffect(eff);
              } catch { }
            }
          },
            (marker && React.createElement('div', { className: `tt-marker ${marker === 'FINISH' ? 'finish' : ''}` }, marker)),
            React.createElement('div', { className: 'tt-tile-num' }, isStart ? '' : `#${tile.tileNumber}`),

            // Icon or name: NEVER show on START
            !isStart && hasIcon
              ? React.createElement('img', {
                src: tile.iconFile,
                className: 'tt-tile-icon',
                draggable: false,
                onError: (e) => { e.currentTarget.style.display = 'none'; }
              })
              : !isStart && React.createElement('div', { className: 'tt-tile-name' }, (tile.name || 'Untitled')),

            // Effect badge overlay: NEVER on START
            (!isStart && kind !== 'none') && React.createElement('div', { className: 'tt-eff', title: kind },
              iconUrl
                ? React.createElement('img', {
                  src: iconUrl,
                  alt: kind,
                  onError: (e) => { e.currentTarget.replaceWith(Object.assign(document.createElement('div'), { className: 'tt-eff-fallback', innerText: (kind || '').split('_').map(s => s[0]).join('').slice(0, 2).toUpperCase() })); }
                })
                : React.createElement('div', { className: 'tt-eff-fallback' }, (kind || '').split('_').map(s => s[0]).join('').slice(0, 2).toUpperCase())
            )
          )
        )
      );
    }



    function EffectEditor({ tile, onChange }) {
      const eff = tile.effect || { kind: 'none' };
      const def = EFFECTS.find(e => e.kind === eff.kind) || EFFECTS[0];

      const update = (patch) => {
        const nextEff = { ...eff, ...patch };
        if (nextEff.kind === 'none') {
          return onChange({
            effect: { kind: 'none' },
            meta: { presetId: 'none', opts: {}, attached: false }
          });
        }
        const opts = {};
        if ('amount' in nextEff) opts.amount = Number(nextEff.amount);
        if ('index' in nextEff) opts.index = Number(nextEff.index);
        onChange({
          effect: nextEff,
          meta: { presetId: nextEff.kind, opts, attached: true }
        });
      };

      return (
        React.createElement('div', { className: 'space-y-3' },
          React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1 editor-prose' }, 'Effect'),
              React.createElement('select', {
                className: 'w-full rounded-lg border-slate-300',
                value: eff.kind || 'none',
                onChange: e => {
                  const nextKind = e.target.value;
                  const meta = EFFECTS.find(x => x.kind === nextKind) || EFFECTS[0];
                  update({
                    kind: nextKind,
                    trigger: nextKind === 'none' ? undefined : (meta.defaultTrigger || 'on_next_roll'),
                    amount: undefined,
                    index: undefined
                  });
                }
              }, EFFECTS.map(x => React.createElement('option', { key: x.kind, value: x.kind }, x.label)))
            ),
            (eff.kind !== 'none') &&
            React.createElement('div', { className: 'flex items-center gap-2' },
              React.createElement('div', { className: 'tt-eff' },
                React.createElement('img', {
                  src: getEffectIconUrl(eff.kind),
                  alt: eff.kind,
                  onError: (e) => { e.currentTarget.replaceWith(Object.assign(document.createElement('div'), { className: 'tt-eff-fallback', innerText: (eff.kind || '').split('_').map(s => s[0]).join('').toUpperCase().slice(0, 2) })); }
                })
              ),
              React.createElement('div', { className: 'text-xs text-slate-600' }, `Effect: ${eff.kind}${eff.amount != null ? ` | amount=${eff.amount}` : ''}${eff.index != null ? ` | index=${eff.index}` : ''}`)
            ),
            (eff.kind !== 'none') && React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Trigger'),
              React.createElement('select', {
                className: 'w-full rounded-lg border-slate-300',
                value: eff.trigger || def.defaultTrigger || 'on_next_roll',
                onChange: e => update({ trigger: e.target.value })
              }, [
                React.createElement('option', { key: 'on_next_roll', value: 'on_next_roll' }, 'on_next_roll'),
                React.createElement('option', { key: 'on_land', value: 'on_land' }, 'on_land')
              ])
            )
          ),
          eff.kind === 'none'
            ? React.createElement('div', { className: 'text-xs text-slate-500' }, 'No effect will be applied for this tile.')
            : (def.params || []).map(p => React.createElement('div', { key: p.name },
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, p.name),
              React.createElement('input', {
                className: 'w-full rounded-lg border-slate-300',
                type: 'number', min: p.min, step: p.step || 1, placeholder: p.placeholder || '',
                value: eff[p.name] ?? '',
                onChange: (e) => update({ [p.name]: e.target.value === '' ? undefined : Number(e.target.value) })
              })
            )
            )
        )
      );
    }

function EditorPanel({ tile, setTile, onDuplicate, onDelete }) {
  const { useState } = React;
  const [openPicker, setOpenPicker] = useState(false);

  if (!tile) {
    return React.createElement('div', { className: 'text-slate-500' }, 'Select a tile to edit.');
  }

  const isStart = String(tile.id) === '1';

  if (isStart) {
    // START tile: fixed, no icon picker here
    return React.createElement('div', { className: 'space-y-3' },
      React.createElement('div', { className: 'text-sm text-emerald-700 font-medium' }, 'START tile (fixed)'),
      React.createElement('p', { className: 'text-xs text-slate-600' }, 'This tile is fixed, cannot be dragged, and cannot have a name or effect.'),
      React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
        React.createElement('div', null,
          React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'ID'),
          React.createElement('input', { className: 'w-full rounded-lg border-slate-300 bg-slate-100 text-slate-500', value: tile.id, disabled: true, readOnly: true })
        ),
        React.createElement('div', null,
          React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Tile Number'),
          React.createElement('input', { className: 'w-full rounded-lg border-slate-300 bg-slate-100 text-slate-500', value: tile.tileNumber, disabled: true, readOnly: true })
        )
      )
    );
  }

  const update = (patch) => setTile({ ...tile, ...patch });

  return React.createElement('div', { className: 'space-y-4' },
    React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
      React.createElement('div', null,
        React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'ID'),
        React.createElement('input', { className: 'w-full rounded-lg border-slate-300 bg-slate-100 text-slate-500', value: tile.id, disabled: true, readOnly: true })
      ),
      React.createElement('div', null,
        React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Tile Number'),
        React.createElement('input', {
          className: 'w-full rounded-lg border-slate-300',
          type: 'number',
          value: tile.tileNumber,
          onChange: e => update({ tileNumber: Number.isFinite(Number(e.target.value)) ? Number(e.target.value) : tile.tileNumber })
        })
      )
    ),

    React.createElement('div', null,
      React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Name'),
      React.createElement('input', { className: 'w-full rounded-lg border-slate-300', value: tile.name, onChange: e => update({ name: e.target.value }) })
    ),

    React.createElement('div', null,
      React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Description'),
      React.createElement('textarea', { className: 'w-full rounded-lg border-slate-300', rows: 4, value: tile.desc, onChange: e => update({ desc: e.target.value }) })
    ),

    // ICON URL + PICKER (non-start tiles only)
    React.createElement('div', null,
      React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Icon URL (iconFile)'),
      React.createElement('input', {
        className: 'w-full rounded-lg border-slate-300',
        placeholder: 'https://‚Ä¶ or use ‚ÄúPick from OSRS Wiki‚Äù',
        value: tile.iconFile,
        onChange: e => update({ iconFile: e.target.value })
      }),
      React.createElement('div', { className: 'flex gap-2 mt-2' },
        React.createElement('button', {
          className: 'btn-stone',
          onClick: () => setOpenPicker(true)
        }, 'Pick from OSRS Wiki'),
        React.createElement('button', {
          className: 'btn-stone',
          onClick: () => update({ iconFile: '' })
        }, 'Clear')
      )
    ),

    // Effect editor
    React.createElement('div', null,
      React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-2' }, 'Effect'),
      React.createElement(EffectEditor, { tile, onChange: (patch) => update(patch) })
    ),

    React.createElement('div', { className: 'flex gap-2' },
      React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700', onClick: onDuplicate }, 'Duplicate'),
      React.createElement('button', { className: 'px-3 py-2 rounded-lg bg-rose-600 text-white hover:bg-rose-700', onClick: onDelete }, 'Delete')
    ),

    // Modal appears only for non-start tiles
openPicker && React.createElement(IconPicker, {
  initialQuery: '',
  onPick: (url) => update({ iconFile: url }),
  onClose: () => setOpenPicker(false)
})
  );
}


    function EffectBuilderPanel() {
      const [kind, setKind] = useState('none');
      const [trigger, setTrigger] = useState('on_next_roll');
      const [amount, setAmount] = useState('');
      const [index, setIndex] = useState('');

      const meta = EFFECTS.find(e => e.kind === kind) || EFFECTS[0];
      const needsAmount = meta.params.some(p => p.name === 'amount');
      const needsIndex = meta.params.some(p => p.name === 'index');
      const iconUrl = getEffectIconUrl(kind);

      const payload = {
        kind,
        ...(kind === 'none' ? {} : { trigger }),
        ...(amount !== '' ? { amount: Number(amount) } : {}),
        ...(index !== '' ? { index: Number(index) } : {}),
      };

      const onDragStart = (e) => {
        const text = JSON.stringify(payload);
        e.dataTransfer.setData('application/json', text);
        e.dataTransfer.setData('text/tt-effect', text);
        e.dataTransfer.effectAllowed = 'copy';

        // Try a custom drag image using the effect icon (fallback to the token element)
        if (iconUrl) {
          const img = new Image();
          img.src = iconUrl;
          img.onload = () => {
            e.dataTransfer.setDragImage(img, 10, 10);
          };
        }
      };

      return (
        React.createElement('div', { className: 'space-y-3' },
          React.createElement('div', { className: 'grid grid-cols-2 gap-3' },
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Effect'),
              React.createElement('select', { className: 'w-full rounded-lg border-slate-300', value: kind, onChange: e => setKind(e.target.value) },
                EFFECTS.map(x => React.createElement('option', { key: x.kind, value: x.kind }, x.label))
              )
            ),
            (kind !== 'none') && React.createElement('div', null,
              React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'Trigger'),
              React.createElement('select', { className: 'w-full rounded-lg border-slate-300', value: trigger, onChange: e => setTrigger(e.target.value) },
                [
                  React.createElement('option', { key: 'on_next_roll', value: 'on_next_roll' }, 'on_next_roll'),
                  React.createElement('option', { key: 'on_land', value: 'on_land' }, 'on_land'),
                ]
              )
            )
          ),
          (needsAmount) && React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'amount'),
            React.createElement('input', { className: 'w-full rounded-lg border-slate-300', type: 'number', min: 1, step: 1, value: amount, onChange: e => setAmount(e.target.value) })
          ),
          (needsIndex) && React.createElement('div', null,
            React.createElement('label', { className: 'block text-xs font-medium text-slate-600 mb-1' }, 'index'),
            React.createElement('input', { className: 'w-full rounded-lg border-slate-300', type: 'number', min: 1, step: 1, value: index, onChange: e => setIndex(e.target.value) })
          ),
          React.createElement('div', { className: 'text-xs text-slate-500' }, 'Drag this token onto a tile to apply the effect:'),
          React.createElement('div', {
            className: 'tt-token',
            draggable: true,
            onDragStart,
            title: 'Drag onto a tile to apply'
          },
            iconUrl && React.createElement('img', { src: iconUrl, alt: kind, onError: (e) => { e.currentTarget.remove(); } }),
            React.createElement('span', null, kind === 'none' ? 'None (clear effect)' : `${kind}${amount !== '' ? ` amt=${amount}` : ''}${index !== '' ? ` idx=${index}` : ''}`)
          )
        )
      );
    }

function IconPicker({ initialQuery = '', onPick, onClose }) {
  const { useState } = React;
  const [q, setQ] = useState(initialQuery || '');
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState('');

  const QUICK = ['Zulrah', 'Vorkath', 'Barrows', 'Slayer', 'Dragon', 'Herblore', 'Agility', 'Fishing', 'Runecraft'];

  const run = async (query) => {
    const term = (query || '').trim();
    if (term.length < 2) { setItems([]); setErr(''); return; }  // avoid spammy calls
    setLoading(true); setErr('');
    try {
      const list = await wikiSearchFiles(term, 40, 192);
      setItems(list);
    } catch {
      setErr('Wiki rate-limited or unreachable. Try again in a moment.');
    } finally {
      setLoading(false);
    }
  };

return React.createElement('div', { className: 'fixed inset-0 z-50 grid place-items-center bg-black/50 p-4' },
  React.createElement('div', { className: 'w-full max-w-3xl panel-medieval p-4' },

    // Header row: input + Search + Close (right-aligned)
    React.createElement('div', { className: 'mb-3 flex items-center gap-2' },
      React.createElement('input', {
        className: 'w-full rounded-lg border-slate-300',
        placeholder: 'Search file name prefix (e.g., "Zulrah", "Dragon", "Herblore")',
        value: q,
        onChange: e => setQ(e.target.value),
        onKeyDown: (e) => {
          if (e.key === 'Enter' && !loading && q.trim().length >= 2) {
            e.preventDefault(); run(q);
          }
        },
        autoFocus: true
      }),
      React.createElement('button', {
        className: 'btn-bronze',
        disabled: (q.trim().length < 2) || loading,
        onClick: () => run(q)
      }, loading ? 'Searching‚Ä¶' : 'Search'),
      React.createElement('button', {
        className: 'btn-stone ml-auto',
        onClick: onClose
      }, 'Close')
    ),

    // Quick chips
    React.createElement('div', { className: 'flex flex-wrap gap-2 mb-3' },
      QUICK.map(term =>
        React.createElement('button', {
          key: term,
          className: 'btn-stone',
          onClick: () => { setQ(term); run(term); }
        }, term)
      )
    ),

    err && React.createElement('div', { className: 'text-sm text-rose-600' }, err),

    // Results grid (unchanged except it applies on click)
    React.createElement('div', { className: 'grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-3 max-h-[60vh] overflow-auto' },
      items.map(f =>
        React.createElement('button', {
          key: f.name,
          className: 'rounded-lg border border-slate-200 bg-white/70 hover:shadow soft p-2 flex flex-col items-center gap-2',
          onClick: () => { onPick?.(f.thumbUrl || f.fileUrl, f); onClose?.(); }
        },
          React.createElement('img', {
            src: f.thumbUrl || f.fileUrl,
            alt: f.name,
            className: 'w-20 h-20 object-contain',
            onError: (e) => { e.currentTarget.style.visibility = 'hidden'; }
          }),
          React.createElement('div', { className: 'text-[10px] text-slate-700 text-center break-all' }, f.name)
        )
      )
    )
  )
);
}

    function Toolbar({ onNew, onClear, onImport, onExport, onRandom, count }) {
      const fileRef = useRef(null);

      const triggerImport = () => fileRef.current && fileRef.current.click();

      const onFile = (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = () => onImport(String(reader.result || ''));
        reader.readAsText(f);
        e.target.value = '';
      }

      return (
        React.createElement('div', { className: 'flex flex-wrap items-center gap-2' },
          React.createElement('button', { className: 'btn-bronze', onClick: onNew }, 'Add Tile'),
          React.createElement('button', { className: 'btn-bronze', onClick: onClear }, 'Clear'),
          React.createElement('button', { className: 'btn-bronze', onClick: onRandom, title: 'Shuffle tiles and apply randomized effects' }, 'Random Board'),
          React.createElement('button', { className: 'btn-bronze', onClick: triggerImport }, 'Import JSON'),
          React.createElement('button', { className: 'btn-bronze', onClick: onExport }, 'Export JSON'),

          React.createElement('input', { ref: fileRef, type: 'file', accept: '.json,application/json', className: 'hidden', onChange: onFile }),
          React.createElement('div', { className: 'ml-auto text-sm text-slate-600' }, `${count} tile${count === 1 ? '' : 's'}`)
        )
      );
    }
    function buildSnakePositions(count, ROW_LEN = 15) {
      const positions = [];
      let x = 0, y = 0, dir = 1;

      for (let i = 0; i < count;) {
        // Horizontal run
        for (let h = 0; h < ROW_LEN && i < count; h++, i++) {
          positions.push({ x, y, type: 'h', hIndex: h, rowIndex: Math.floor(positions.length / ROW_LEN) });
          if (h < ROW_LEN - 1 && i < count) x += dir;
        }
        // Vertical drop
        if (i < count) {
          y++;
          positions.push({ x, y, type: 'drop' });
          i++;
        }
        // Next row
        dir *= -1;
        y++;
      }
      return positions;
    }

    function buildSnakePositionsWithStart(countTiles, rowLen = 15) {
      const total = countTiles + 1; // +1 for START
      const positions = [];
      let x = 0, y = 0, dir = 1;

      // START at (0,0)
      positions.push({ x, y, type: 'start' });

      // Move to first tile slot to the right of START for horizontal run
      if (total > 1) {
        x += 1;
        // Fill remaining slots
        for (let placed = 1; placed < total;) {
          // Horizontal run (rowLen - 1 because START already used one column on the very first row)
          const run = positions.length === 1 ? (rowLen - 1) : rowLen;
          for (let h = 0; h < run && placed < total; h++, placed++) {
            positions.push({ x, y, type: 'h', hIndex: h });
            if (h < run - 1 && placed < total) x += dir;
          }
          if (placed >= total) break;
          // Vertical drop (one tile directly below current end)
          y += 1; placed++;
          positions.push({ x, y, type: 'drop' });
          if (placed >= total) break;

          // Flip direction and move to next horizontal row start
          dir *= -1;
          y += 1;
          // Move to row start x
          x += dir * (rowLen - 1);
        }
      }
      return positions;
    }

    function PreviewGrid({ tiles, onSelect, selectedId, setTiles, onDropEffect }) {
      const listRef = React.useRef(null);
      const ROW_LEN = 15;

      useFitScale(listRef, ROW_LEN);

      // Build positions for ALL playable tiles (1..N)
      const positions = React.useMemo(
        () => buildSnakePositions(tiles.length, ROW_LEN),
        [tiles.length]
      );

      // Identify first-of-row (horizontal) positions AFTER the first row
      const rowStartFlags = React.useMemo(() => {
        const flags = new Array(tiles.length).fill(false);
        let seenRows = 0;
        // A horizontal row starts when type==='h' && hIndex===0
        for (let i = 0; i < positions.length; i++) {
          const p = positions[i];
          if (p.type === 'h' && p.hIndex === 0) {
            // skip the very first horizontal row (no "ROW 1" label)
            if (seenRows > 0) {
              // map back to tile index: positions index == tile index for horizontals & drops
              flags[i] = true;
            }
            seenRows++;
          }
        }
        return flags;
      }, [positions]);

      // Sortable (exclude first tile from dragging by CSS class)
      useSortable(listRef, tiles, (newArr) => {
        // Reorder by DOM and resequence 1..N
        newArr.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
        setTiles(newArr.slice());
      });

      const cellStyleFor = (i) => {
        const p = positions[i];
        return { gridColumn: (p.x + 1), gridRow: (p.y + 1) };
      };

      return (
        React.createElement(
          'div',
          {
            ref: listRef,
            className: 'tt-grid',
            style: { gridTemplateColumns: `repeat(${ROW_LEN}, var(--tile))` },
          },
          tiles.map((t, i) => {
            // Markers: START on first tile, FINISH on last; ROW labels on subsequent horizontal rows
            let marker = null;
            if (i === 0) marker = 'START';
            else if (i === tiles.length - 1) marker = 'FINISH';
            else if (rowStartFlags[i]) {
              // Compute visible row # (1st horizontal row had no label)
              const rowsBefore = rowStartFlags.slice(0, i + 1).filter(Boolean).length;
              marker = `ROW ${rowsBefore + 1}`; // ‚ÄúROW 2‚Äù, ‚ÄúROW 3‚Äù, ‚Ä¶
            }

            return React.createElement(
              'div',
              {
                key: t.id,
                'data-id': t.id,
                className: `tt-cell ${i === 0 ? 'tt-fixed' : ''}`, // first tile is fixed
                style: cellStyleFor(i),
              },
              React.createElement(TileCard, {
                tile: t,
                onSelect: () => onSelect(t.id),
                selected: t.id === selectedId,
                marker,
                onDropEffect: (eff) => onDropEffect(t.id, eff)
              })
            );
          })
        )
      );
    }
    function BoardSettings({ count }) {
      const rows = Math.ceil(count / 15);
      return React.createElement('div', { className: 'flex flex-wrap items-center gap-4' },
        React.createElement('div', null,
          React.createElement('div', { className: 'heading-medieval text-sm' }, 'Columns: 15 (fixed)')
        ),
        React.createElement('div', null,
          React.createElement('div', { className: 'heading-medieval text-sm' }, 'Path: Snake (always on)')
        ),
        React.createElement('div', { className: 'ml-auto heading-medieval text-sm' }, `Rows: ${rows}`)
      );
    }

    function App() {
      const applyEffectToTile = (tileId, eff) => {
        if (String(tileId) === '1') return; // ‚Üê ignore START defensively
        setTiles(prev => prev.map(t => {
          if (t.id !== tileId) return t;
          if (!eff || eff.kind === 'none') {
            return { ...t, effect: { kind: 'none' }, meta: { presetId: 'none', opts: {}, attached: false } };
          }
          const opts = {};
          if ('amount' in eff) opts.amount = Number(eff.amount);
          if ('index' in eff) opts.index = Number(eff.index);
          return {
            ...t,
            effect: { ...eff },
            meta: { presetId: eff.kind, opts, attached: true }
          };
        }));
      };
      const [tiles, setTiles] = useState(() => {
        try {
          const saved = JSON.parse(localStorage.getItem('tt-editor-tiles') || 'null');
          if (Array.isArray(saved) && saved.length) return saved;
        } catch { }
        return Array.from({ length: 10 }, (_, i) => makeDefaultTile(i + 1));
      });
      const cols = 15;
      const snake = true;
      const [selectedId, setSelectedId] = useState(tiles[0]?.id || null);

      useEffect(() => { localStorage.setItem('tt-editor-tiles', JSON.stringify(tiles)); }, [tiles]);
      useEffect(() => { localStorage.setItem('tt-editor-snake', snake ? '1' : '0'); }, [snake]);

      const selectedTile = useMemo(() => tiles.find(t => t.id === selectedId) || null, [tiles, selectedId]);

      const replaceTile = (next) => {
        setTiles(prev => prev.map(t => t.id === next.id ? next : t).sort((a, b) => a.tileNumber - b.tileNumber).map((t, i) => ({ ...t, tileNumber: i + 1, id: String(i + 1) })));
      };

      const addTile = () => {
        setTiles(prev => {
          const n = prev.length + 1;
          const t = makeDefaultTile(n);
          return [...prev, t];
        });
        setSelectedId(prev => null);
      };

      const randomizeBoard = () => {
        setTiles(prev => {
          if (!Array.isArray(prev) || prev.length <= 1) return prev;

          // Copy and split: keep START (index 0) fixed
          const head = { ...prev[0] };
          const rest = prev.slice(1).map(t => ({ ...t }));

          // Shuffle the playable tiles
          for (let i = rest.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [rest[i], rest[j]] = [rest[j], rest[i]];
          }

          // Clear effects first
          for (const t of rest) {
            t.effect = { kind: 'none' };
            t.meta = { presetId: 'none', opts: {}, attached: false };
          }

          // Decide how many tiles to effect
          const playableCount = rest.length;
          const toAffect = effectTargetCount(playableCount);

          // Choose unique target indices in rest[]
          const picks = new Set();
          while (picks.size < toAffect) {
            picks.add(Math.floor(Math.random() * playableCount)); // 0..playableCount-1
          }

          // Pool of effect kinds (exclude 'none')
          const kinds = EFFECTS.map(e => e.kind).filter(k => k !== 'none');

          // Apply randomized effects
          for (const idx of picks) {
            const kind = kinds[Math.floor(Math.random() * kinds.length)];
            const eff = buildRandomEffect(kind, playableCount);
            const opts = {};
            if ('amount' in eff) opts.amount = eff.amount;
            if ('index' in eff) opts.index = eff.index;

            rest[idx].effect = eff;
            rest[idx].meta = { presetId: eff.kind, opts, attached: true };
          }

          // Ensure START tile is clean
          head.effect = { kind: 'none' };
          head.meta = { presetId: 'none', opts: {}, attached: false };

          const next = [head, ...rest];

          // Resequence IDs and tileNumbers 1..N
          next.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });

          return next;
        });
      };

      const clearAll = () => {
        if (confirm('Clear all tiles?')) {
          setTiles([]);
          setSelectedId(null);
        }
      };

      const importJSON = (text) => {
        try {
          const raw = JSON.parse(text);
          const extracted = extractTilesFromAny(raw);
          if (!Array.isArray(extracted) || !extracted.length) {
            alert('No tiles found in JSON.'); return;
          }
          const norm = normalizeImportedTiles(extracted);
          setTiles(norm);
          setSelectedId(norm[0]?.id || null);
        } catch (e) {
          alert('Invalid JSON: ' + e.message);
        }
      };

      const exportJSON = () => {
        const out = tiles.map(t => {
          const eff = t.effect || null;
          const isNone = !eff || eff.kind === 'none';
          const metaOpts = {};
          if (eff && 'amount' in eff) metaOpts.amount = eff.amount;
          if (eff && 'index' in eff) metaOpts.index = eff.index;

          const obj = {
            id: String(t.id),
            tileNumber: Number(t.tileNumber),
            name: t.name || '',
            desc: t.desc || '',
            iconFile: t.iconFile || ''
          };

          obj.effect = isNone ? null : { ...eff };
          if (!isNone) obj.meta = { presetId: eff.kind || 'move_forward', opts: metaOpts, attached: true };

          return obj;
        });
        const text = JSON.stringify(out, null, 2);
        download('board.json', text);
      };

      const duplicateSelected = () => {
        if (!selectedTile) return;
        const copy = JSON.parse(JSON.stringify(selectedTile));
        delete copy.id;
        setTiles(prev => {
          const idx = prev.findIndex(t => t.id === selectedTile.id);
          const next = prev.slice();
          next.splice(idx + 1, 0, copy);
          next.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
          return next;
        });
      };

      const deleteSelected = () => {
        if (!selectedTile) return;
        if (!confirm('Delete this tile?')) return;
        setTiles(prev => {
          const next = prev.filter(t => t.id !== selectedTile.id);
          next.forEach((t, i) => { t.tileNumber = i + 1; t.id = String(i + 1); });
          return next;
        });
        setSelectedId(null);
      };

      return (
        React.createElement('div', { className: 'mx-auto p-6 space-y-6' },
          React.createElement('header', { className: 'flex items-center gap-3' },
            React.createElement('div', { className: 'w-10 h-10 rounded-xl bg-indigo-600 text-white grid place-items-center font-bold' }, 'TT'),
            React.createElement('div', null,
              React.createElement('h1', { className: 'text-xl font-semibold text-slate-900' }, 'TileTrials Board Editor'),
              React.createElement('p', { className: 'text-slate-600 text-sm' }, 'Drag, edit, and export a board.json compatible with your /tiletrials importboard command.')
            )
          ),

          React.createElement('div', { className: 'panel-medieval p-4' },
            React.createElement(Toolbar, {
              onNew: addTile,
              onClear: clearAll,
              onImport: importJSON,
              onExport: exportJSON,
              onRandom: randomizeBoard,
              count: tiles.length
            })
          ),

          React.createElement('div', { className: 'panel-medieval p-4' },
            React.createElement(BoardSettings, { count: tiles.length })
          ),

          React.createElement('div', { className: 'tt-layout' },
            // Left: Board area
            React.createElement('div', { className: 'space-y-3' },
              React.createElement('div', { className: 'tt-board-wrap' },
                React.createElement(PreviewGrid, {
                  tiles,
                  onSelect: setSelectedId,
                  selectedId,
                  setTiles,
                  onDropEffect: (tileId, eff) => applyEffectToTile(tileId, eff)
                })
              ),
              React.createElement('div', { className: 'text-xs text-slate-500 editor-prose' }, 'Tip: drag a tile to reorder. Export to download the JSON.')
            ),

            // Right: Editor
            React.createElement('aside', { className: 'panel-medieval p-4 space-y-6 editor-prose' },
              React.createElement('div', null,
                React.createElement('h2', { className: 'text-sm font-semibold text-slate-700 mb-3 editor-prose' }, 'Tile Editor'),
                React.createElement(EditorPanel, {
                  tile: selectedTile,
                  setTile: replaceTile,
                  onDuplicate: duplicateSelected,
                  onDelete: deleteSelected
                })
              ),
              React.createElement('div', null,
                React.createElement('h2', { className: 'text-sm font-semibold text-slate-700 mb-3 editor-prose' }, 'Effect Builder'),
                React.createElement(EffectBuilderPanel, null)
              )
            )
          ),

          React.createElement('footer', { className: 'text-center text-xs text-slate-500 pt-2 editor-prose' }, 'Made to work with OSClanTools Discord Bot - By Wni.')
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App));
  </script>
  <a id="authLink" class="btn-bronze inline-flex items-center gap-2" href="/auth/login">Login</a>
</body>

</html>
